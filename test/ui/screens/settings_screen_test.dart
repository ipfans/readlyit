import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:readlyit/app/ui/screens/settings_screen.dart';
import 'package:readlyit/features/articles/presentation/providers/article_providers.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart'; // For AppLocalizations
// import 'package:readlyit/core/services/database_service.dart'; // Not directly needed if ArticlesListNotifier is well mocked
import 'package:readlyit/features/articles/data/datasources/remote/pocket_service.dart'; // For PocketService
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'settings_screen_test.mocks.dart'; // Generated by build_runner

// Mock classes needed for providers
// We need to mock ArticlesListNotifier because SettingsScreen calls logoutFromPocket on it.
// We also need to mock PocketService for pocketIsAuthenticatedProvider.
@GenerateNiceMocks([MockSpec<PocketService>()])
class MockArticlesListNotifier extends Mock implements ArticlesListNotifier {}

void main() {
  // Ensure Flutter bindings are initialized for tests
  TestWidgetsFlutterBinding.ensureInitialized();

  // Helper function to pump the widget with necessary providers and MaterialApp
  Future<void> pumpSettingsScreen(
    WidgetTester tester, {
    required List<Override> overrides,
  }) async {
    await tester.pumpWidget(
      ProviderScope(
        overrides: overrides,
        child: const MaterialApp(
          localizationsDelegates: AppLocalizations.localizationsDelegates,
          supportedLocales: AppLocalizations.supportedLocales,
          home: SettingsScreen(),
        ),
      ),
    );
  }

  // Mock instances
  late MockPocketService mockPocketService;
  late MockArticlesListNotifier mockArticlesListNotifier;

  setUp(() {
    mockPocketService = MockPocketService();
    mockArticlesListNotifier = MockArticlesListNotifier();
    
    // It's important that ArticlesListNotifier itself doesn't throw errors during construction in tests
    // if its dependencies (like DatabaseService) are not fully mocked or provided.
    // For this test, we only care about the `logoutFromPocket` method.
  });


  testWidgets('SettingsScreen displays titles and initial sections', (WidgetTester tester) async {
    await pumpSettingsScreen(tester, overrides: [
      pocketIsAuthenticatedProvider.overrideWithValue(const AsyncValue.data(false)),
      // Provide a default for articlesListProvider if its notifier is accessed indirectly
      // For settings screen, it's directly accessed for logout.
      articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
    ]);

    // Wait for localizations to load
    await tester.pump(); 

    expect(find.text('Settings', skipOffstage: false), findsOneWidget); // AppBar title (English)
    expect(find.text('Appearance', skipOffstage: false), findsOneWidget);
    expect(find.text('Pocket Integration', skipOffstage: false), findsOneWidget);
    expect(find.text('iCloud Sync (iOS/macOS)', skipOffstage: false), findsOneWidget);
  });

  group('Pocket Integration Section', () {
    testWidgets('when not authenticated, shows connect button', (WidgetTester tester) async {
      // No need to 'when' mockPocketService.isAuthenticated() if overriding pocketIsAuthenticatedProvider directly
      // unless the provider's logic itself calls it multiple times in complex ways.

      await pumpSettingsScreen(tester, overrides: [
        pocketIsAuthenticatedProvider.overrideWithValue(const AsyncValue.data(false)),
        articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
      ]);
      await tester.pumpAndSettle(); // Settle for AsyncValue

      expect(find.text('Not connected to Pocket', skipOffstage: false), findsOneWidget);
      expect(find.widgetWithText(ElevatedButton, 'Connect to Pocket', skipOffstage: false), findsOneWidget);
    });

    testWidgets('when authenticated, shows logout button and status', (WidgetTester tester) async {
      // Stub the logoutFromPocket method
      when(mockArticlesListNotifier.logoutFromPocket()).thenAnswer((_) async {});


      await pumpSettingsScreen(tester, overrides: [
        pocketIsAuthenticatedProvider.overrideWithValue(const AsyncValue.data(true)),
        articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
      ]);
      await tester.pumpAndSettle();

      expect(find.text('Authenticated with Pocket', skipOffstage: false), findsOneWidget);
      expect(find.widgetWithText(ElevatedButton, 'Logout', skipOffstage: false), findsOneWidget);
    });

    testWidgets('tapping Logout button calls logoutFromPocket and invalidates provider', (WidgetTester tester) async {
      
      // Initial state: Authenticated
      when(mockPocketService.isAuthenticated()).thenAnswer((_) async => true);
      
      // Define what logoutFromPocket does
      when(mockArticlesListNotifier.logoutFromPocket()).thenAnswer((_) async {
        // Simulate behavior: after logout, isAuthenticated becomes false for the *next* call
        when(mockPocketService.isAuthenticated()).thenAnswer((_) async => false);
      });

      await pumpSettingsScreen(tester, overrides: [
        pocketIsAuthenticatedProvider.overrideWith((ref) async {
          // This will be called initially and again upon invalidation
          return await mockPocketService.isAuthenticated(); 
        }),
        articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
      ]);
      
      await tester.pumpAndSettle(); // Initial state: authenticated
      expect(find.text('Authenticated with Pocket', skipOffstage: false), findsOneWidget);
      
      await tester.tap(find.widgetWithText(ElevatedButton, 'Logout'));
      await tester.pumpAndSettle(); // Process tap, provider invalidation, and rebuild

      verify(mockArticlesListNotifier.logoutFromPocket()).called(1);
      // After logout, the provider should have been re-evaluated (due to ref.invalidate)
      // and returned false, leading to UI update.
      expect(find.text('Not connected to Pocket', skipOffstage: false), findsOneWidget); 

      // Check for SnackBar (ensure a ScaffoldMessenger is available)
      // SnackBar is shown by SettingsScreen using its own context.
      expect(find.text('Logged out from Pocket.', skipOffstage: false), findsOneWidget);
      await tester.pumpAndSettle(const Duration(seconds: 3)); // Wait for SnackBar to disappear
      expect(find.text('Logged out from Pocket.', skipOffstage: false), findsNothing);

    });

    testWidgets('when provider returns error, shows error message', (WidgetTester tester) async {
      final exception = Exception('Pocket API Error');
      await pumpSettingsScreen(tester, overrides: [
        pocketIsAuthenticatedProvider.overrideWithValue(AsyncValue.error(exception, StackTrace.current)),
        articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
      ]);
      await tester.pumpAndSettle();

      expect(find.text('Error checking Pocket status.', skipOffstage: false), findsOneWidget);
      expect(find.text(exception.toString(), skipOffstage: false), findsOneWidget);
    });
  });
}
