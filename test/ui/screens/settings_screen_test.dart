import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:readlyit/app/ui/screens/settings_screen.dart';
import 'package:readlyit/features/articles/presentation/providers/article_providers.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart'; 
import 'package:readlyit/features/articles/data/datasources/remote/pocket_service.dart'; 
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

// Import SharedPreferences for mocking
import 'package:shared_preferences/shared_preferences.dart';
// Import the notifiers and their enums/types
import 'package:readlyit/app/ui/theme/theme_providers.dart';
import 'package:readlyit/l10n/language_providers.dart';

import 'settings_screen_test.mocks.dart'; // Generated by build_runner

// Update mock generation annotations
@GenerateNiceMocks([
  MockSpec<PocketService>(),
  MockSpec<SharedPreferences>(), // Added
  MockSpec<ThemeModeNotifier>(), // Added
  MockSpec<SeedColorNotifier>(), // Added
  MockSpec<LanguageNotifier>(),  // Added
  // ArticlesListNotifier is manually mocked below
])

// Manual mock for ArticlesListNotifier (as it's more complex)
class MockArticlesListNotifier extends Mock implements ArticlesListNotifier {}

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late MockPocketService mockPocketService;
  late MockArticlesListNotifier mockArticlesListNotifier;
  late MockSharedPreferences mockSharedPreferences; // New
  late MockThemeModeNotifier mockThemeModeNotifier; // New
  late MockSeedColorNotifier mockSeedColorNotifier; // New
  late MockLanguageNotifier mockLanguageNotifier;   // New

  setUp(() {
    mockPocketService = MockPocketService();
    mockArticlesListNotifier = MockArticlesListNotifier();
    mockSharedPreferences = MockSharedPreferences(); // Initialize
    mockThemeModeNotifier = MockThemeModeNotifier(); // Initialize
    mockSeedColorNotifier = MockSeedColorNotifier(); // Initialize
    mockLanguageNotifier = MockLanguageNotifier();   // Initialize

    // Default stubs for notifiers
    when(mockThemeModeNotifier.state).thenReturn(AppThemeMode.system);
    when(mockThemeModeNotifier.currentMaterialThemeMode).thenReturn(ThemeMode.system); // Ensure this is stubbed
    when(mockSeedColorNotifier.state).thenReturn(AppColorSeed.blue);
    when(mockLanguageNotifier.state).thenReturn(const Locale('en')); // Default to English
    // Provide a list of supported locales for the dropdown
    when(mockLanguageNotifier.supportedLocales).thenReturn([const Locale('en'), const Locale('zh')]);
    // availableAppLocales is a global list, so no need to stub if LanguageNotifier.supportedLocales is used by UI

    // Default stubs for ArticlesListNotifier methods used in SettingsScreen
    when(mockArticlesListNotifier.logoutFromPocket()).thenAnswer((_) async {});
    when(mockArticlesListNotifier.initiatePocketAuthentication()).thenAnswer((_) async => null); // Success case
  });

  Future<void> pumpSettingsScreen(
    WidgetTester tester, {
    List<Override> overrides = const [],
    bool isAuthenticated = false, // Default Pocket auth state
  }) async {
    // Mock the isAuthenticated call within pocketIsAuthenticatedProvider's logic
    // This is simpler than mocking the provider to return a pre-resolved AsyncValue for some tests
    // if the provider's internal logic itself calls mockPocketService.isAuthenticated().
    // However, for direct AsyncValue testing (like error/loading states), overriding with AsyncValue is better.
    // For this setup, we'll override pocketIsAuthenticatedProvider to directly return based on `isAuthenticated`.
    
    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          pocketIsAuthenticatedProvider.overrideWithValue(AsyncValue.data(isAuthenticated)),
          articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
          themeModeProvider.overrideWith((ref) => mockThemeModeNotifier),
          seedColorProvider.overrideWith((ref) => mockSeedColorNotifier),
          languageProvider.overrideWith((ref) => mockLanguageNotifier),
          ...overrides,
        ],
        child: const MaterialApp(
          localizationsDelegates: AppLocalizations.localizationsDelegates,
          supportedLocales: AppLocalizations.supportedLocales,
          home: SettingsScreen(),
        ),
      ),
    );
    await tester.pumpAndSettle(); // Ensure all initial states are processed and UI settles
  }

  testWidgets('SettingsScreen displays titles and initial sections', (WidgetTester tester) async {
    await pumpSettingsScreen(tester); // Defaults to not authenticated

    expect(find.text('Settings', skipOffstage: false), findsOneWidget); 
    expect(find.text('Appearance', skipOffstage: false), findsOneWidget);
    expect(find.text('Theme Mode', skipOffstage: false), findsOneWidget);
    expect(find.text('Theme Color', skipOffstage: false), findsOneWidget);
    // Language can appear twice (section title + list tile title)
    expect(find.text('Language', skipOffstage: false), findsNWidgets(2)); 
    expect(find.text('Font Settings', skipOffstage: false), findsOneWidget);
    expect(find.text('Pocket Integration', skipOffstage: false), findsOneWidget);
    expect(find.text('iCloud Sync (iOS/macOS)', skipOffstage: false), findsOneWidget);
  });

  group('Theme Settings', () {
    testWidgets('displays Theme Mode dropdown and allows selection', (WidgetTester tester) async {
      await pumpSettingsScreen(tester);

      expect(find.text('Theme Mode', skipOffstage: false), findsOneWidget);
      expect(find.text('System', skipOffstage: false), findsOneWidget); // Initial value

      await tester.tap(find.byType(DropdownButton<AppThemeMode>).first);
      await tester.pumpAndSettle(); 

      await tester.tap(find.text('Dark', skipOffstage: false).last);
      await tester.pumpAndSettle();

      verify(mockThemeModeNotifier.setThemeMode(AppThemeMode.dark)).called(1);
    });

    testWidgets('displays Theme Color dropdown and allows selection', (WidgetTester tester) async {
      await pumpSettingsScreen(tester);

      expect(find.text('Theme Color', skipOffstage: false), findsOneWidget);
      expect(find.text('Blue', skipOffstage: false), findsOneWidget); // Initial value (label from enum)

      await tester.tap(find.byType(DropdownButton<AppColorSeed>).first);
      await tester.pumpAndSettle();

      await tester.tap(find.text(AppColorSeed.green.label, skipOffstage: false).last);
      await tester.pumpAndSettle();

      verify(mockSeedColorNotifier.setSeedColor(AppColorSeed.green)).called(1);
    });
  });

  group('Language Settings', () {
    testWidgets('displays Language dropdown and allows selection', (WidgetTester tester) async {
      await pumpSettingsScreen(tester);
      
      expect(find.text('Language', skipOffstage: false), findsNWidgets(2));
      expect(find.text('English', skipOffstage: false), findsOneWidget); // Initial value

      await tester.tap(find.byType(DropdownButton<Locale>).first);
      await tester.pumpAndSettle();

      await tester.tap(find.text('Chinese', skipOffstage: false).last);
      await tester.pumpAndSettle();

      verify(mockLanguageNotifier.setLanguage(const Locale('zh'))).called(1);
    });
  });
  
  group('Pocket Integration Section in Settings', () {
    testWidgets('when not authenticated, Connect button calls initiatePocketAuthentication and shows redirect SnackBar', (WidgetTester tester) async {
        // Ensure initiatePocketAuthentication returns null (success for launching URL)
        when(mockArticlesListNotifier.initiatePocketAuthentication()).thenAnswer((_) async => null);

        await pumpSettingsScreen(tester, isAuthenticated: false);

        expect(find.text('Not connected to Pocket', skipOffstage: false), findsOneWidget);
        final connectButton = find.widgetWithText(ElevatedButton, 'Connect to Pocket');
        expect(connectButton, findsOneWidget);

        await tester.tap(connectButton);
        await tester.pumpAndSettle();

        verify(mockArticlesListNotifier.initiatePocketAuthentication()).called(1);
        // Verify the specific SnackBar text
        expect(find.text('Please authorize with Pocket in your browser. The app will continue once authorization is complete.', skipOffstage: false), findsOneWidget);
        
        await tester.pumpAndSettle(const Duration(seconds: 3)); // Wait for SnackBar to disappear
        expect(find.text('Please authorize with Pocket in your browser. The app will continue once authorization is complete.', skipOffstage: false), findsNothing);
    });

    testWidgets('when not authenticated and initiatePocketAuthentication fails, shows error SnackBar', (WidgetTester tester) async {
        final String errorMessage = "Failed to launch URL";
        when(mockArticlesListNotifier.initiatePocketAuthentication()).thenAnswer((_) async => errorMessage);

        await pumpSettingsScreen(tester, isAuthenticated: false);
        final connectButton = find.widgetWithText(ElevatedButton, 'Connect to Pocket');
        await tester.tap(connectButton);
        await tester.pumpAndSettle();

        verify(mockArticlesListNotifier.initiatePocketAuthentication()).called(1);
        // Verify the specific error SnackBar text (uses pocketSyncFailed key)
        expect(find.text('Pocket Sync Failed: $errorMessage', skipOffstage: false), findsOneWidget);
    });

    // Existing tests for authenticated state, logout, and error for pocketIsAuthenticatedProvider
    // should be adapted to use the new pumpSettingsScreen and mock setups if not already.
    // Example: Adapting the logout test
    testWidgets('tapping Logout button calls logoutFromPocket and invalidates provider', (WidgetTester tester) async {
      // No need to mock mockPocketService.isAuthenticated() directly if pocketIsAuthenticatedProvider is overridden effectively
      // for its different states.
      
      // Initial state: Authenticated
      await pumpSettingsScreen(tester, isAuthenticated: true);
      expect(find.text('Authenticated with Pocket', skipOffstage: false), findsOneWidget);
      
      await tester.tap(find.widgetWithText(ElevatedButton, 'Logout'));
      
      // After tap, we need to re-pump with the new (mocked) unauthenticated state
      // This simulates the provider invalidation and rebuild.
      // The actual invalidation happens in the real notifier, here we test the UI reaction.
      // So, for the test, we re-pump with isAuthenticated: false.
      // The verify call ensures the action was attempted.
      await pumpSettingsScreen(tester, isAuthenticated: false); // Simulate state after logout & invalidation
      
      verify(mockArticlesListNotifier.logoutFromPocket()).called(1);
      expect(find.text('Not connected to Pocket', skipOffstage: false), findsOneWidget); 

      expect(find.text('Logged out from Pocket.', skipOffstage: false), findsOneWidget);
      await tester.pumpAndSettle(const Duration(seconds: 3)); 
      expect(find.text('Logged out from Pocket.', skipOffstage: false), findsNothing);
    });

    testWidgets('when pocketIsAuthenticatedProvider returns error, shows error message', (WidgetTester tester) async {
      final exception = Exception('Pocket API Error');
      // Override pocketIsAuthenticatedProvider to return an error state directly
      await pumpSettingsScreen(
        tester, 
        overrides: [
          pocketIsAuthenticatedProvider.overrideWithValue(AsyncValue.error(exception, StackTrace.current)),
          // other necessary provider overrides remain as in pumpSettingsScreen's defaults
          articlesListProvider.overrideWith((ref) => mockArticlesListNotifier),
          themeModeProvider.overrideWith((ref) => mockThemeModeNotifier),
          seedColorProvider.overrideWith((ref) => mockSeedColorNotifier),
          languageProvider.overrideWith((ref) => mockLanguageNotifier),
        ]
      );
      // No need to call pumpAndSettle if pumpSettingsScreen does it.

      expect(find.text('Error checking Pocket status.', skipOffstage: false), findsOneWidget);
      expect(find.text(exception.toString(), skipOffstage: false), findsOneWidget);
    });
  });
}
